/* luoguP1126 */
/** 记忆化搜索 **/
/**
 *n*m的网格(n,m<=50)，网格中有障碍物
 *机器人有4个方向，东E，南S，西W，北N
 *机器人有5种移动方式：向前1/2/3步，原地左转/右转
 *机器人移动耗费1s
 *给定起始位置坐标，方向，和终点位置坐标，求最少时间
 *****************
 *分析：由图我们可以将网格转化为点，最左一列是0列，因此是一个0~n*0~m的数组
 *经观察，在数组中我们障碍物四角记作障碍即可
 *由于四个方向导致状态数过多，dfs怕炸了（那bfs不也会炸嘛。。。）所以用bfs
 *坑：移动时移1/2/3步不行就break，否则会出现3步绕过障碍物的情况
 **/
#include<cstdio>
#include<queue>
#include<cstring>
#include<limits.h>
using namespace std;
const int N=55;
int n,m,X1,X2,Y1,Y2;
char start;
bool mp[N][N],vst[N][N][4];
//int f[N][N][4];
//0为北N，1为西W，2为南S，3为东E
struct node
{
    int x,y,dir,cnt;
    node(int xx,int yy,int direction,int pace):x(xx),y(yy),dir(direction),cnt(pace){}
};
int main()
{
    //memset(f,-1,sizeof(f));
    scanf("%d%d",&n,&m);
    for(int i=0;i<n;i++)
        for(int j=0;j<m;j++)
        {
            int a;
            scanf("%d",&a);
            if(a) mp[i][j]=mp[i+1][j]=mp[i][j+1]=mp[i+1][j+1]=1;
        }
    for(int i=0;i<=m;i++)
        mp[0][i]=mp[n][i]=1;
    for(int i=0;i<=n;i++)
        mp[i][0]=mp[i][m]=1;
    char c;
    scanf("%d%d%d%d %c",&X1,&Y1,&X2,&Y2,&c);
    /*
    for(int i=0;i<=n;i++,putchar('\n'))
        for(int j=0;j<=m;j++)
            printf("%d ",mp[i][j]);
            */
    if(c=='N') start=0;
    else if(c=='W') start=1;
    else if(c=='S') start=2;
    else start=3;
    //每一步都是1s，不需要优先队列来优化bfs了
    queue<node> q;
    q.push(node(X1,Y1,start,0));
    while(!q.empty())
    {
        node cur=q.front();
        q.pop();
        int x=cur.x,y=cur.y,nx,ny,dir=cur.dir;
        //printf("%d %d %d %d\n",x,y,dir,cur.cnt);
        if(vst[x][y][dir]) continue;
        if(x==X2&&y==Y2)
        {
            printf("%d",cur.cnt);
            return 0;
        }
        //f[x][y][dir]=cur.cnt;
        vst[x][y][dir]=true;
        if(dir==0)//4个方向道理相同
        {
            for(int i=1;i<=3;i++)//跑1/2/3步
            {
                nx=x-i;
                if(nx<0||mp[nx][y]) break;//小的都过不去大的一定过不去，必须break
                q.push(node(nx,y,dir,cur.cnt+1));
            }
            //转两个方向
            q.push(node(x,y,1,cur.cnt+1));
            q.push(node(x,y,3,cur.cnt+1));
        }
        else if(dir==1)
        {
            for(int i=1;i<=3;i++)
            {
                ny=y-i;
                if(ny<0||mp[x][ny]) break;
                q.push(node(x,ny,dir,cur.cnt+1));
            }
            q.push(node(x,y,0,cur.cnt+1));
            q.push(node(x,y,2,cur.cnt+1));
        }
        else if(dir==2)
        {
            for(int i=1;i<=3;i++)
            {
                nx=x+i;
                if(nx>n||mp[nx][y]) break;
                q.push(node(nx,y,dir,cur.cnt+1));
            }
            q.push(node(x,y,1,cur.cnt+1));
            q.push(node(x,y,3,cur.cnt+1));
        }
        else
        {
            for(int i=1;i<=3;i++)
            {
                ny=y+i;
                if(ny>n||mp[x][ny]) break;
                q.push(node(x,ny,dir,cur.cnt+1));
            }
            q.push(node(x,y,0,cur.cnt+1));
            q.push(node(x,y,2,cur.cnt+1));
        }
    }
    printf("-1");
    return 0;
}

