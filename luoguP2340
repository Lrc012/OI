/* luoguP2340 ** USACO03FALL */ 
/* AC */
/**
*n头奶牛，每头奶牛有情商s和智商f
*选择一定数量的奶牛，使得情商之和>0，智商之和>0，且智商+情商和最大
*1 ≤ N ≤ 400，−1000 ≤ Si; Fi ≤ 1000
**/
/**
*由于中途可能产生负数，所以不能直接动规，这里选择将数组平移
*平移之后动规的改变见代码注释
******
*坑：动规数组初始化
**/
#include<cstdio>
#include<algorithm>
#include<cstring>
using namespace std;
const int N=8e5;
int dp[N+5],s[405],f[405];
//以情商/智商中的一个作为背包体积，另一个作为价值，最后看dp[i]+i就可
int main()
{
    int n;
    scanf("%d",&n);
    memset(dp,-0x3f,sizeof(dp));
    //因为结果有负数，所以必须用一个足够小的数初始化
    for(int i=1;i<=n;i++)
        scanf("%d%d",s+i,f+i);
    dp[N>>1]=0;
    //平移数组后的0点初始化为0
    //似乎是为了防止达不到的体积被赋上正值？感觉是这样，道理是什么呢？
    for(int i=1;i<=n;i++)
        if(s[i]>=0) //正常的01背包
            for(int j=N;j>=s[i];j--)
                dp[j]=max(dp[j],dp[j-s[i]]+f[i]);
        else //如果是负数，背包体积会增加，如果倒序会使用刚更新的结果
             //因此是正序枚举
            for(int j=0;j<=N+s[i];j++)
                dp[j]=max(dp[j],dp[j-s[i]]+f[i]);
    int maxn=0;
    for(int i=N>>1;i<=N;i++)
        if(dp[i]>=0) maxn=max(maxn,dp[i]+i);
    maxn-=N>>1;
    if(maxn>=0) printf("%d",maxn);
    else printf("0");
    return 0;
}
