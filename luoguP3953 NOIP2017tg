/* luoguP3953 NOIP2017tg */
/** 最短路+dfs **/
/**
 *n个节点m条有向带权边的图，无自环和重边，从1进，n出
 *设最短路长度为d，给定k和p，求不超过k+d长度的路径个数mod p的结果
 *若路径有无数条则输出-1
 **/
/*********************************
 *纯暴力法：只AC了4个点，其他全部tle，没考虑环（即-1），下一步优化考虑拓扑找环
 *两遍Dijkstra，找出正向图（1出发）和反向图（n出发）到各点的最短路径
 *从1点dfs找路，利用反向图得到的最短路径剪枝
 *********************************/
#include<cstdio>
#include<queue>
#include<cstring>
#include<utility>
#include<iostream>
using namespace std;
#define INF 0x7fffffff
typedef pair<int,int> P;
const int N=1e5+3;
int n,m,k,p,ans;
int tot,minn;
int head[N],d[N];
int hd[N],dd[N];
bool vst[N];
void read(int& x){
    x=0;
    int f=1;
    char ch=getchar();
    while(ch<'0'||ch>'9'){
        if(ch=='-') f=-1;
        ch=getchar();
    }
    while(ch>='0'&&ch<='9'){
        x=x*10+ch-'0';
        ch=getchar();
    }
    x*=f;
}
struct Edge
{
    int u,v,val,nxt,frm;
}edge[N<<1];
void add_edge()
{
    int u,v,val;
    read(u),read(v),read(val);
    edge[++tot].u=u;
    edge[tot].v=v;
    edge[tot].val=val;
    edge[tot].nxt=head[u];
    edge[tot].frm=hd[v];
    head[u]=tot;
    hd[v]=tot;
}
void dfs(int x,int t)
{
    if(x==n)
    {
        if(t<=minn)
            ans=(ans+1)%p;
        return;
    }
    if(t+dd[x]>minn)
        return;
    for(int i=head[x];~i;i=edge[i].nxt)
        dfs(edge[i].v,t+edge[i].val);
}
int main()
{
    int t;
    read(t);
    while(t--)
    {
        memset(head,-1,sizeof(head));
        memset(hd,-1,sizeof(hd));
        memset(vst,0,sizeof(vst));
        tot=minn=ans=0;
        read(n),read(m),read(k),read(p);
        for(int i=1;i<=n;i++)
            d[i]=INF;
        for(int i=1;i<=m;i++)
            add_edge();
        priority_queue<P,vector<P>,greater<P> > q;
        q.push(P(0,1));
        d[1]=0;
        while(!q.empty())
        {
            int cur=q.top().second;
            q.pop();
            if(vst[cur])
                continue;
            vst[cur]=true;
            for(int i=head[cur];~i;i=edge[i].nxt)
            {
                int to=edge[i].v,value=edge[i].val;
                if(d[to]>d[cur]+value)
                {
                    d[to]=d[cur]+value;
                    q.push(P(d[to],to));
                }
            }
        }
        memset(vst,0,sizeof(vst));
        for(int i=1;i<=n;i++)
            dd[i]=INF;
        q.push(P(0,n));
        dd[n]=0;
        while(!q.empty())
        {
            int cur=q.top().second;
            q.pop();
            if(vst[cur])
                continue;
            vst[cur]=true;
            for(int i=hd[cur];~i;i=edge[i].frm)
            {
                int to=edge[i].u,value=edge[i].val;
                if(dd[to]>dd[cur]+value)
                {
                    dd[to]=dd[cur]+value;
                    q.push(P(dd[to],to));
                }
            }
        }
        minn=d[n]+k;
        dfs(1,0);
        printf("%d\n",ans);
    }
    return 0;
}
