/* luoguP3956 NOIP2017pj */
/** bfs/dfs，剪枝 **/
/**
 *m*m的棋盘有n个有色格子，输入m，n，及每个格子的颜色（1为黄，0为红）
 *从左上角走到左下角，必须只能站在有颜色的格子
 *规则：上下左右四个方向，颜色相同则不耗费金币，颜色不同则耗费1金币
 *可以将无色变成指定颜色，花费2金币，走上去之后不能再次使用魔法变色，离开时格子变回无色
 *求最小花费金币，不能到达输出-1
 *1<=m<=100,1<=n<=1000
 ***********
 *注意等号情况剪枝也得剪掉
 **/
#include<cstdio>
#include<cstring>
#include<algorithm>
using namespace std;
const int N=105,INF=N*N*2;
const int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
int mp[N][N],f[N][N];
bool vst[N][N];
int m,n;
int ans;
void print()
{
    for(int i=1;i<=m;i++,putchar('\n'))
        for(int j=1;j<=m;j++)
            printf("%d ",mp[i][j]);
}
void dfs(int x,int y,int cur,bool magic)
{
    if(cur>=f[x][y])//一开始没加等号就TLE了
        return;
    f[x][y]=cur;
    if(x==m&&y==m)
    {
        ans=cur;//前面已经保证cur一定比f[x][y]小，那么一定能保证比之前的ans小
        return;
    }
    for(int i=0;i<4;i++)
    {
        int nx=x+dx[i],ny=y+dy[i];//四个方向
        if(nx<=0||nx>m||ny<=0||ny>m||vst[nx][ny])
            continue;
        if(mp[nx][ny]==-1)//无颜色
        {
            if(magic) continue;//这步已经变过色，不行
            vst[nx][ny]=true;
            mp[nx][ny]=mp[x][y];
            //这里应该是题目表述不严谨
            //变色只能变成和现在脚下相同的颜色，不能随意指定
            dfs(nx,ny,cur+2,true);
            vst[nx][ny]=false;
            mp[nx][ny]=-1;
        }
        else
        {
            vst[nx][ny]=true;
            if(mp[nx][ny]==mp[x][y])
                dfs(nx,ny,cur,false);
            else dfs(nx,ny,cur+1,false);
            vst[nx][ny]=false;
        }
    }
}
int main()
{
    memset(mp,-1,sizeof(mp));
    memset(f,INF,sizeof(f));
    ans=INF;
    scanf("%d%d",&m,&n);
    for(int i=0;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        scanf("%d",&mp[x][y]);
    }
    vst[1][1]=true;
    if(mp[1][1]!=-1)
        dfs(1,1,0,false);
    if(ans==INF) printf("-1");
    else printf("%d",ans);
    return 0;
}
/* bfs做法
#include<cstdio>
#include<cstring>
#include<algorithm>
#include<queue>
using namespace std;
const int N=105,INF=N*N*2;
const int dx[4]={0,0,1,-1},dy[4]={1,-1,0,0};
int mp[N][N];
bool vst[N][N];
int m,n;
int ans;
struct node//bfs时每一步所需要的信息写一个结构体
{
    int x,y,cnt,color;
    bool operator < (const node& a) const
    {//便于优先队列的使用
        return cnt>a.cnt;
    }
    node(int a,int b,int c,int d):x(a),y(b),cnt(c),color(d){}
};
void print()
{
    for(int i=1;i<=m;i++,putchar('\n'))
        for(int j=1;j<=m;j++)
            printf("%d ",mp[i][j]);
}
int main()
{
    memset(mp,-1,sizeof(mp));
    ans=INF;
    scanf("%d%d",&m,&n);
    for(int i=0;i<n;i++)
    {
        int x,y;
        scanf("%d%d",&x,&y);
        scanf("%d",&mp[x][y]);
    }
    //print();
    priority_queue<node> q;
    q.push(node(1,1,0,mp[1][1]));
    while(!q.empty())
    {
        node cur=q.top();//取出来的时为止花费最少的
        q.pop();
        int x,y,nx,ny;
        x=cur.x,y=cur.y;
        if(vst[x][y]) continue;
        vst[x][y]=true;
        if(x==m&&y==m)
        {
            ans=cur.cnt;
            break;
        }
        bool magic=false;
        if(mp[x][y]!=cur.color)//如果当前脚下颜色跟初始不一样说明上一步变了色
            magic=true;
        for(int i=0;i<4;i++)
        {
            nx=x+dx[i],ny=y+dy[i];//四个方向
            if(nx<=0||nx>m||ny<=0||ny>m)
                continue;
            if(mp[nx][ny]==-1)
            {
                if(magic) continue;//不可继续变色
                q.push(node(nx,ny,cur.cnt+2,cur.color));
            }
            else if(mp[nx][ny]==cur.color)
                q.push(node(nx,ny,cur.cnt,cur.color));
            else q.push(node(nx,ny,cur.cnt+1,mp[nx][ny]));
        }
    }
    if(ans==INF) printf("-1");
    else printf("%d",ans);
    return 0;
}
*/
