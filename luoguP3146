/* luoguP3146 ** USACO16OPEN */ 
/* 区间dp */
/**
 *n个数字一行，2048玩法，相邻相等的数合并，结果为原数+1
 *求最终的最高得分
 **/
#include<cstdio>
#include<algorithm>
using namespace std;
const int N=250;
int a[N],dp[N][N];
int main()
{
    int n;
    scanf("%d",&n);
    for(int i=1;i<=n;i++)
    {
        scanf("%d",a+i);
        dp[i][i]=a[i];
        //为了后面合并时能够进行两个相邻的合并
    }
    for(int len=1;len<n;len++)
        for(int l=1,r=l+len;l<=n&&r<=n;l++,r++)
        {
            int ans=0;
            for(int k=l;k<r;k++)
                if(dp[l][k]&&dp[k+1][r]&&dp[l][k]==dp[k+1][r])
                //dp[l][r]表示将[l,r]区间合并得到的最高分
                //如果一个都没有，就不能合并，最后结果是0，这个地方洛谷数据弱了，不判断0也过了
                    ans=max(ans,dp[l][k]+1);
            dp[l][r]=ans;
        }
    int ans=0;
    for(int i=1;i<=n;i++)
        for(int j=i+1;j<=n;j++)
            ans=max(ans,dp[i][j]);
    printf("%d",ans);
    return 0;
}
