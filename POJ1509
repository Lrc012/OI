/* POJ1509 */
/** SAM **/
/**
 *t组数据，每组是一个长小于1e6的字符串，头尾相接
 *输出字典序最小且序号最小的开头位置
 **/
#include<cstdio>
#include<cstring>
#include<map>
using namespace std;
const int N=1e4+5;
char s[N];
template<int SZ,int SIG=32>
struct Suffix_Automaton {
    int link[SZ], len[SZ], last, sz;
    map<char, int> next[SZ];
    inline void init()
    {
        sz = 0;
        last = new_node();
    }
    inline int new_node()
    {
        //assert(sz + 1 < SZ);
        int nd = sz++;
        next[nd].clear(), link[nd] = -1, len[nd] = 0;
        return nd;
    }
    inline void insert(char x)
    {
        int p = last, cur = new_node();
        len[last = cur] = len[p] + 1;
        while (p != -1 && !next[p].count(x))
            next[p][x] = cur, p = link[p];
        if (p == -1)
        {
            link[cur] = 0;
            return;
        }
        int q = next[p][x];
        if (len[p] + 1 == len[q])
        {
            link[cur] = q;
            return;
        }
        int nq = new_node();
        next[nq] = next[q];
        link[nq] = link[q], len[nq] = len[p] + 1, link[cur] = link[q] = nq;
        while (p >= 0 && next[p][x] == q)
            next[p][x] = nq, p = link[p];
        return;
    }
    inline void build(char* s)
    {
        while (*s)
            insert(*s++);
    }
};
Suffix_Automaton<N<<2> SAM;
int main()
{
    int t;
    scanf("%d",&t);
    while(t--)
    {
        scanf("%s",s);
        SAM.init();
        SAM.build(s);
        SAM.build(s);//拆环成链，首尾相接建树
        int p=0,len=strlen(s);
        for(int i=0;i<len;i++)
            p=SAM.next[p].begin()->second;
            //每次都走最小边，走len步得到的就是字典序最小
        printf("%d\n",SAM.len[p]-len+1);
    }
    return 0;
}
